# Руководство по модуляризации кода - MassMeta style, v0.3

## Чем тщательнее вы соблюдаете правила из этого руководства - тем меньше претензий будет к вам, и ваш PR будет быстрее замержан в репозиторий.

## Вступление

Разработка и поддержка отдельной код-базы, что постоянно подсасывает обновления с основного проекта (в нашем случае это /TG/station) - это ну ооочень непростая задача, многие подобные "типо модульные" проекты утонули в грязном коде (посмотри в код Монке-станции), а подобные "Авгиевые конюшни" поддерживать - та ещё запара.

Поймите, чем больше разрастается наш модульный код - тем тщательнее нужно его поддерживать для дальнейшей нашей работы.

Удобство сопровождения вашего дополнительного кода - является одной из основных причин соблюдения МОДУЛЬНОСТИ у нашего проекта.

Хорошо организованный и документированный код избавляет наш Моск при дальнейшем "обновлении до оффов ТГ" или внесении новой нашей "фичи". **Сделай все сразу качественно как можешь.**

Этот документ будет обновляться и изменяться каждый раз, когда в него будут добавляться новые исключения. Возможно, время от времени стоит проверять, возможно тут появится более правильный/удобный прием модуляризации.

GitHub - это одна из многих видов систем контроля версий (СКВ). Мы на ней т.к. оффы ТГ тоже на ней. Сам Git одновременно и достаточно проработан в плане алгоритмов, он ими же и ограничен. Они не всегда могут однозначно разрешить определенные изменения в коде, что приводит к конфликтам, которые придется Вам починять вручную.

**Все Баг-фиксы и прочую дичь Ты льешь только в корневой проект ТГ**

## Важное примечание - ТЕСТИРУЙТЕ СВОИ PR'ы

Как ответственный  ТГ К*дер - Вы несете ответственность за тестирование вашего контента. Ты - это и тестировщик, что тестирует свой продукт для клиентов - игроков. А игроков на сервере обычно больше 1-го, то порой нужно проверять вашу фичу вдвоем/втроем/итд.

Если вам нужен отдельный клиент для тестирования, вы можете использовать гостевой аккаунт, выйдя из BYOND-хаба и зайдя на локалку как Guest. Как только вас уже доконал этот кодинг фичи - закидывай PR на репозиторий и жди пока тебе его починят (заставят переделывать твоими же ручками).

### Итак, у Вас возник конфликт...

Например, пускай в оригинале у нас было так:

```byond
var/something = 1
```

и мы такие хотим изменить вон то значение с 1 на 2 для нашего проекта,

```diff
- var/something = 1
+ var/something = 2 //MASSMETA EDIT
```

но затем наш доблестный ТГ К*дер с оффов вносит свои изменения в корневую код-базу, меняя ее с 1 на 4

```diff
- var/something = 1
+ var/something = 4
```

Как бы ни был прост данный пример, но он приводит к относительно простому конфликту в виде, ой...

```byond
var/something = 2 //MASSMETA EDIT
```

Где мы начинаем думать головой, чтобы выбрать наилучший вариант выхода из казуса вручную.

### Выходы из ситуации

ТЫ - ТОТ КТО РЕШАЕТ КОНФЛИКТЫ, ПРОГРАММА - ГЛУПА И ГОТОВА В ЛЮБОЙ МОМЕНТ ПОДСТАВИТЬ ТЕБЯ, НЕ НАДЕЙСЯ НА НЕЁ!

Ну так о чем мы... Ах да, МОДУЛЯРИЗАЦИЯ!

**Модуляризация** означает, что большинство изменений и дополнений, которые мы делаем, будут храниться в отдельной папке **`modular_meta/`**, как можно более независимой от основного кода. В свою очередь те, которые абсолютно не могут быть модульными, должны быть особым образом отмечены комментариями, указывающими, где начинаются изменения, где они заканчиваются, и к какой функции они относятся.

## Протокол модуляризации

«Как корабль назовешь, так он и поплывет». Придумайте короткое (но информативное) название для своего пиара для дальнейших пометок ваших изменений в коде. (Вы аналогично можете назвать вашу ветку (Branch) в вашем репозитории). После того как вы придумали название - Проверь, нет ли уже подобного в проекте!

Короч, придумываешь уникальный индикатор своего модуля для твоего кода. Например, `DNA-FEATURE-WINGS` или `XENOARCHEAOLOGY` или `SHUTTLE_TOGGLE` - Мы будем использовать его в будущей документации. По сути, это идентификатор вашего модуля. Он должен быть единым во всех ваших изменениях/дополнениях. Все ссылки ДОЛЖНЫ быть абсолютно одинаковыми! Это необходимо для удобства поиска. - УДОБНО!

Затем вам нужно создать основную папку, в которой вы будете локально работать, назови сразу её, как и ID твоего модуля. Например, `modular_meta/modules/shuttle_toggle`.

### Карты (модульно с картами мы ничего не делаем)

IMPORTANT: MAP CONTRIBUTION GUIDELINES HAVE BEEN UPDATED

When you are adding a new item to the map you MUST follow this procedure:
Start by deciding how big of a change it is going to be, if it is a small 1 item change, you should use the simple area automapper. If it is an entire room, you should use the template automapper.

We will no longer have _nova map versions.

DO NOT CHANGE TG MAPS, THEY ARE HELD TO THE SAME STANDARD AS ICONS. USE THE ABOVE TO MAKE MAP EDITS.

The automapper uses prebaked templates to override sections of a map using coordinates to plot the starting location. See entries in automapper_config.toml for examples.

The simple area automapper uses datum entries to place down a single item in an area of a map that makes vauge sense.

### Ресурсы: изображения (.png), звуки (.ogg), значки (.dmi) и прочие бинарники (= не Текст).

Git сам по себе может справиться с конфликтами двоичных файлов, однако Вы - нет. Для вас бинарник будет выглядеть как беспорядочный набор всякого, поэтому вносить изменения в основные Бинарные файлы категорически не рекомендуется.

Все (кроме TGUI, строк и конфигов) добавленные нами файлы должны быть помещены в ту же модульную папку, что и ваш код. Это означает, что все хранится в папке вашего модуля: звуки, значки и файлы кода. - УДОБНО!

- ***Пример:*** Решили Вы добавить нового моба для лаваленда.

  Прежде всего вы создаете свою модульную папку. Например: `modular_meta/modules/lavalandmob`

  Далее Вы создаете подпапки для каждого компонента (если нужно). Например. `/code` для кода, `/sounds` для звуковых файлов и `/icons` для любых файлов картинок/значков.

  После этого вам нужно будет установить ссылки на ваши файлы в коде.

  ```byond
    /mob/lavaland/newmob
      icon = 'modular_meta/modules/lavalandmob/icons/mob.dmi'
      icon_state = "dead_1"
      sound = 'modular_meta/modules/lavalandmob/sounds/boom.ogg'
  ```

  Это гарантирует нам, что ваш код является полностью модульным и облегчит его будущие изменения.

- С прочими "нетекстовыми" файлами следует обращаться аналогичным образом, в зависимости от контекста каждого конкретного случая. Если у вас есть сомнения, обратитесь за советами и предложениями к сопровождающему или другим участникам.

- Any additional clothing icon files you add MUST go into the existing files in master_files clothing section. (чё?)

### Папка `master_files` (oh yes Sir!)

Вы всегда должны помещать любые модульные переопределения значков, звуков, кода и т. д. в эту папку, и они **должны** соответствовать структуре папки основного кода.

Пример: `code/modules/mob/living/living.dm` -> `modular_meta/master_files/code/modules/mob/living/living.dm`

Это сделано для того, чтобы было проще выяснить, что вы или кто-то другой поменяли в Базовом файле, без необходимости поиска в определениях процедур.

Это также помогает предотвратить многократное переопределение одного и того же процесса модулями. Более подробная информация об этих типах редактирования расскажется позже.

### Полностью модульные части вашего кода

Раздел ниже относительно прост, там будет рассказано об основах Модульности с понятными примерами, так как руководство предназначено, скорее, для новичков.

Правило гласит, что если вы сможете обойтись без этого, то не следует вносить изменения в файлы основной код-базы. За некоторыми исключениями, которые будут упомянуты в ближайшее время.

Короче говоря, большая часть модульного кода будет размещена во вложенных папках вашей основной папки модуля **`modular_meta/modules/yourmodule/code/`**, с теми же правилами, что и в случае с остальными файлами. Не отражайте структуру папок основного кода в модульной папке!

Например, `modular_meta/modules/xenoarcheaology/code`, содержит весь код, инструменты, предметы и прочее, связанные с ним.

Такие модули, за исключением _очень_ простых, **должны** иметь в своей папке `readme.md`, содержащий следующее:

- ссылки на PR'ы, которые внедрили этот модуль или внесли в него какие-либо существенные изменения
- краткое описание модуля
- список файлов, измененных в коде ядра, с кратким описанием изменений, а также список изменений в других модульных файлах, не являющихся частью того же модуля, которые были необходимы для правильной работы этого модуля
- (опционально) немного более подробная документация для корректировки кода на будущее, которая будет полезна при дальнейшем развитии и сопровождении
- авторство

***Примерный Шаблон:*** [Тык](module_template.md)

## Модульные переопределения (важно!!)

Обратите внимание, что можно модульно добавлять код перед или за основной процедурой, не редактируя исходную процедуру, а обращаясь к родительской процедуре с помощью `. = ..()` или `..()`. Аналогичным образом можно добавить новый var к существующему datum или obj, не редактируя напрямую файлы офф ТГ.

**Примечание о переопределении proc: Если вы можете, это не значит, что вы должны!!!**

В целом, такой подход является хорошей идеей и поощряется, когда это возможно. Однако это не жесткое правило, и иногда "//MASSMETA EDIT" предпочтительнее. Просто постарайтесь использовать здравый смысл в этом вопросе.

Например: пожалуйста, не вставляйте всю TG-процедуру в модульную переопределённую процедуру, внесите одно небольшое изменение, а затем объявите её "полностью модульной". Эти процедуры - абсолютный кошмар для поддержки, потому что как только что-то изменится, вам придется обновлять переопределенную процедуру.

Иногда вы даже не знаете о существовании переопределения, если оно компилируется нормально и не вызывает никаких ошибок. Это часто приводит к тому, что функции, которые были добавлены выше по течению, здесь отсутствуют. Так что да. Избегайте этого. Нет ничего страшного, если что-то не является полностью модульным. Иногда это лучший выбор из двух зол.

Лучшими кандидатами для модульных переопределений proc являются те, в которых вы можете просто добавить что-то после вызова родителя или ловко вплести вызов родителя в середину, чтобы достичь желаемого эффекта.

Производительность также следует учитывать, когда вы переопределяете горячую (часто вызываемую) процедуру (например, Life()), поскольку каждый дополнительный вызов увеличивает накладные расходы сервера. В таких случаях редактирование "//MASSMETA EDIT" намного критичны к общей производительности кода. Однако для большинства процедур об этом даже и не нужно беспокоиться.

### Эти модульные переопределения должны храниться именно в `master_files`, и вам следует по возможности избегать их размещения внутри модулей.

Для простоты предположим, что вы хотите заставить оружие искрить при выстреле для имитации дульной вспышки и вы хотите, чтобы это можно было использовать с любыми видами оружия.

В модульном файле можно начать с добавления переменной var.

```byond
/obj/item/gun
    var/muzzle_flash = TRUE
```

И все будет работать как полагается. После этого, допустим, вы захотите проверить var и вызвать искры после выстрела.
Зная, что исходный proc, вызываемый при стрельбе, является

```byond
/obj/item/gun/proc/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
```

вы можете определить для него дочернюю процедуру, которая будет вставлена в цепочку наследования связанных с ней процедур (выглядит на вид сложно, но в таких простых случаях, как этот, вам не нужно беспокоиться)

```byond
/obj/item/gun/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
    . = ..() //. is the default return value, we assign what the parent proc returns to it, as we call it before ours
    if(muzzle_flash)
        spawn_sparks(src) //For simplicity, I assume you've already made a proc for this
```

На этом мы закончили с основами.

### Немодульные изменения основного кода - ВАЖНО

Время от времени наступает момент, когда редактирование основных файлов становится неизбежным.

Пожалуйста, не забудьте записать readme.md вашего модуля. Любые изменения всех этих файлов.

В этих случаях мы решили применить следующую стандартизацию с примерами:

- **Добавление:**

  ```byond
  //MASSMETA EDIT ADDITION BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
  var/adminEmergencyNoRecall = FALSE
  var/lastMode = SHUTTLE_IDLE
  var/lastCallTime = 6000
  //MASSMETA EDIT ADDITION END
  ```

- **Удаление:**

  ```byond
  //MASSMETA EDIT REMOVAL BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
  /*
  for(var/obj/docking_port/stationary/S in stationary)
    if(S.id = id)
      return S
  */
  //MASSMETA EDIT REMOVAL END
  WARNING("couldn't find dock with id: [id]")
  ```

  И для любых удалений, которые перемещаются в другие файлы:

  ```byond
  //MASSMETA EDIT REMOVAL BEGIN - SHUTTLE_TOGGLE - (Moved to modular_meta/shuttle_toggle/randomverbs.dm)
  /*
  /client/proc/admin_call_shuttle()
  set category = "Admin - Events"
  set name = "Call Shuttle"

  if(EMERGENCY_AT_LEAST_DOCKED)
    return

  if(!check_rights(R_ADMIN))
    return

  var/confirm = alert(src, "You sure?", "Confirm", "Yes", "No")
  if(confirm != "Yes")
    return

  SSshuttle.emergency.request()
  SSblackbox.record_feedback("tally", "admin_verb", 1, "Call Shuttle") //If you are copy-pasting this, ensure the 2nd parameter is unique to the new proc!
  log_admin("[key_name(usr)] admin-called the emergency shuttle.")
  message_admins(span_adminnotice("[key_name_admin(usr)] admin-called the emergency shuttle."))
  return
  */
  //MASSMETA EDIT REMOVAL END
  ```

- **Изменения:**

  ```byond
  //MASSMETA EDIT CHANGE BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
  //if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE) - MASSMETA EDIT - ORIGINAL
  if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE, SHUTTLE_DISABLED)
  //MASSMETA EDIT CHANGE END
      return 1
  ```

## Особые случаи модульного кода

Из каждого правила есть исключения, обусловленные множеством обстоятельств.

### Определения

В связи с тем, как Byond загружает файлы, возникла необходимость создать отдельную папку для работы с нашими модульными определениями.
Это папка **`code/__DEFINES/~meta_defines`**, в которой вы можете добавлять их к существующим файлам или создавать эти файлы по мере необходимости.

Если у вас есть определение, которое используется более чем в одном файле, оно **обязательно** должно быть объявлено здесь.

Если у вас есть define, который используется в одном файле и больше нигде не предполагается, объявите его вверху файла, а `#undef MY_DEFINE` - внизу файла. Это нужно для того, чтобы сохранить чистоту контекстных меню и не запутать тех, кто использует IDE (по типу VS Code) с автозаполнением.

### Компоновка модульной папки
Чтобы сохранить общий стиль и обеспечить удобную навигацию по большинству модулей, а также контролировать количество файлов и папок в репозитории, вы должны следовать этой схеме.

Убедитесь, что имена папок точно соответствуют указанным.

Самая верхняя папка: module_id

**НЕ КОПИРУЙТЕ ФАЙЛОВУЮ СТРУКТУРУ ОСНОВНОГО КОДА ОФФОВ ТГ В СВОЙ МОДУЛЬ!!!**

**Code** (код): Все файлы .DM должны располагаться здесь.

- Делай так: /modular_meta/modules/example_module/code/disease_mob.dm
- НЕ так: /modular_meta/modules/example_module/code/modules/antagonists/disease/disease_mob.dm

**Icons** (изображения/иконки): Все файлы .DMI должны располагаться здесь.

- Делай так: /modular_meta/modules/example_module/icons/mining_righthand.dmi
- НЕ так: /modular_meta/modules/example_module/icons/mob/inhands/equipment/mining_righthand.dmi

**Sound** (звуки/музыка): Все файлы .OGG должны располагаться здесь.

- Делай так: /modular_meta/modules/example_module/sound/space_dragon_roar.ogg
- НЕ так: /modular_meta/modules/example_module/sound/creatures/space_dragon_roar.ogg

Файл Readme следует поместить в родительскую папку module_id.

**ДЕРЖИТЕ РАЗНЫЕ ТИПЫ ФАЙЛОВ ПО СВОИ ПАПКАМ!**

### Комментировнный код (= неиспользуемый) - НЕ ДЕЛАЙТЕ ЭТОГО

Если вы комментируете избыточный код в модулях - значит его нужно полностью удалить.

Даже если вы думаете, что кто-то собирается переделать то, что вы закомментировали, не делайте этого, gitblame существует не просто так, (прим. от переводчика: есть такая команда 'git blame', что позволяет показать, кто именно редактировал эту строчку).

Это относится и к файлам, не комментируйте целые файлы, просто удалите это безобразие. Это поможет нам избежать раздувания файлов и бессмысленных комментариев. Тем более вы всегда можете посмотреть что было именно в этом файле просто нажав "Посмотреть историю изменений".

**Это не относится к немодульным изменениям.**

### Иерархия инклюдов (includes.dm) ваших модулей

У Скайратов (в данном случае у Nova Sector) все новые файлы сразу включаются в общий файл tgstation.dme, что я считаю достаточно трудным для дальнейшней поддрежки, да и в целом не особо согласуется с их модульным принципом.

В корне папки /modular_meta лежит файл modular_meta.dme (он и только он, включен в общий tgstation.dme)

В этом файле описаны все дополнения, которые мы добавили в наш проект Модульно. Они тоже представлены в виде .dme файлов. (например hardsuits.dme)

Каждый такой .dme файл в каждом модуле содержит в себе все наши дополнительные модульные-файлы.

Таким образом мы соблюдаем некую иерархию.

### Вставка в код своих строковых (.txt .json) и config файлов

Помещаете свои файлы в подпапку **`strings/~modular_meta_strings`**.
По аналогии и config-файлами **`config/~modular_meta_config`**.

Не забывайте выставлять правильный файловый путь к вашему файлу с учетом новой подпапки!

## Модульный TGUI (TG User Interface)

TGUI - еще один исключительный случай, поскольку он использует javascript и не может быть модульным, как тот же код DM.

ВСЕ файлы tgui находятся в папке `/tgui/packages/tgui/interfaces` и ее подкаталогах; отдельной папки для пользовательских интерфейсов Massmeta не существует.

### Изменение файлов самих офф ТГ

При изменении оригинальных файлов TGUI действуют те же правила, что и при изменении вышележащего кода DM, однако грамматика комментариев тут несколько иная.

Вы можете использовать как `// MASSMETA EDIT`, так и `/* MASSMETA EDIT */`, хотя в некоторых случаях вам придется использовать одно вместо другого. (в некотрых языках '//' - могут не являться комментированием, учтите это)

В целом, старайтесь, чтобы комментарии к изменениям находились на той же строке, что и само изменение. Предпочтительно внутри JSX-тега. Например:

```js
<Button
	onClick={() => act('spin', { high_quality: true })}
	icon="rat" // MASSMETA EDIT ADDITION
</Button>
```

```js
<Button
	onClick={() => act('spin', { high_quality: true })}
	// MASSMETA EDIT ADDITION START - another example, multiline changes
	icon="rat"
	tooltip="spin the rat."
	// MASSMETA EDIT ADDITION END
</Button>
```

```js
<SomeThing someProp="whatever" /* it also works in self-closing tags */ />
```

Если это не представляется возможным, вы можете заключить ваше редактирование в фигурные скобки, например так: 

```js
{/* MASSMETA EDIT ADDITION START */} 
<SomeThing>
	someProp="whatever"
</SomeThing>
{/* MASSMETA EDIT ADDITION END */}
```

### Создание новых файлов TGUI 

** ВАЖНО! При создании нового файла TGUI с нуля, пожалуйста, добавьте следующее в самом верху файла (строка 1):**

```js
// THIS IS A MASSMETA UI FILE
```

Таким образом, они легко идентифицируются как модульные файлы TGUI .tsx/.jsx. Собственно ничего больше делать и не нужно, комментарии "//Massmeta Edits" в модульном файле TGUI н.

<!-- ## Exemplary PR's // TODO: REPLACE THESE!

Here are a couple PR's that are great examples of the guide being followed, reference them if you are stuck:

- <https://github.com/Skyrat-SS13/Skyrat-tg/pull/241>
- <https://github.com/Skyrat-SS13/Skyrat-tg/pull/111> -->

## В заключении

Может показаться, что это много, но если мы будем последовательны, то в конечном итоге это избавит НАС от боли в области ГМ, когда НАМ придется разрешать конфликты вручную.
Благодаря более скрупулезному документированию будет сразу понятно, какие изменения были сделаны, где и с помощью каких функций, и все станет гораздо менее двусмысленным и запутанным.

Желаю удачи в ТГ к*динге. Помните, что сообщество всегда готово помочь вам, если вдруг понадобится помощь.
