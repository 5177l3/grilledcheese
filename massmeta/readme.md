# Руководство по модуляризации кода - MassMeta style, v0.3

## Чем тщательнее вы соблюдаете правила из этого руководства - тем меньше претензий будет к вам и ваш PR будет быстрее замержан в репозиторий.

## Вступление

Разработка и поддержка отдельной код-базы, что постоянно подсасывает обновления с основного проекта (в нашем случае это /TG/station) - это ну ооочень непростая задача, многие подобные "типо модульные" проекты утонули в грязном коде (посмотри в код Монке-станции), а подобные "Авгиевые конюшни" поддерживать - та ещё запара.

Поймите, чем больше разрастается наш модульный код - тем тщательнее нужно его поддерживать для дальнейшей нашей работы.

Удобство сопровождения вашего дополнительного кода - является одной из основных причин соблюдения МОДУЛЬНОСТИ у нашего проекта.

Хорошо организованный и документированный код избавляет наш Моск при дальнейшем "обновлении до оффов ТГ" или внесении или удалении "фичи". **Сделай все сразу качественно как можешь.**

Этот документ будет обновляться и изменяться каждый раз, когда в него будут добавляться новые исключения. Возможно, время от времени стоит проверять, возможно тут появится более правильный/удобный прием модуляризации.

GitHub - это одна из многих видов систем контроля версий (СКВ). Мы на ней т.к. оффы ТГ тоже на ней. Сам Git одновременно и достаточно проработан в плане алгоритмов, он ими же и ограничен. Они не всегда могут однозначно разрешить определенные изменения в коде, что приводит к конфликтам, которые придется Вам починять вручную.

**Все Баг-фиксы и прочую дичь Ты льешь только в корневой проект ТГ**

### Важное примечание - ТЕСТИРУЙТЕ СВОИ PR'ы

Как ответственный  ТГ К*дер - Вы несете ответственность за тестирование вашего контента. Ты - это и тестировщик, что тестирует свой продукт для клиентов - игроков. А игроков на сервере обычно больше 1-го, то порой нужно проверять вашу фичу вдвоем/втроем/итд.

Если вам нужен отдельный клиент для тестирования, вы можете использовать гостевой аккаунт, выйдя из BYOND-хаба и зайдя на локалку как Guest. Как только вас уже доконал этот кодинг фичи - закидывай PR на репозиторий и жди пока тебе его починят (заставят переделывать твоими же ручками).

## Из-за чего же весь сыр-бор?

### Итак, у Вас возник конфликт...

Предположим в оригинале у нас было так:

```byond
var/something = 1
```

и вдруг нам протребовалось изменить значение с 1 на 2 для нашего проекта,

```diff
- var/something = 1
+ var/something = 2 //MASSMETA EDIT
```

но внезапно наш доблестный ТГ К*дер с оффов вносит свои изменения в основную код-базу, меняя её с 1 на 4,

```diff
- var/something = 1
+ var/something = 4
```
затем мы решили синхронизировать изменения ни о чём не подозревая, однако видим следующее,

```byond
var/something = 2 //MASSMETA EDIT
```

Как бы ни был прост данный пример, но он приводит к относительно простому конфликту.

Где мы начинаем думать головой, чтобы выбрать наилучший вариант вручную.

### Выходы из ситуации

ТЫ - ТОТ КТО РЕШАЕТ КОНФЛИКТЫ, ПРОГРАММА - ГЛУПА И ГОТОВА В ЛЮБОЙ МОМЕНТ ПОДСТАВИТЬ ТЕБЯ, НЕ НАДЕЙСЯ НА НЕЁ!

Ну так о чем мы... Ах да, МОДУЛЯРИЗАЦИЯ!

**Модуляризация** означает, что большинство изменений и дополнений, которые мы делаем, будут храниться в отдельной папке **`modular_meta/`**, там наш код полностью независим от основного кода. Однако не всегда возможно все сделать полностью модульным, подобные случаи должны быть особым образом отмечены комментариями, указывающими, где начинаются изменения, где они заканчиваются, и к какой функции они относятся.

## Протокол модуляризации

«Как корабль назовешь, так он и поплывет». Придумайте короткое (но информативное) название для своего пиара для дальнейших пометок ваших изменений в коде. (Вы аналогично можете назвать вашу ветку (Branch) в вашем репозитории). После того как вы придумали название - то проверь, нет ли уже подобного в проекте!

Например, `DNA-FEATURE-WINGS` или `XENOARCHEAOLOGY` или `SHUTTLE_TOGGLE` - Мы будем использовать его в будущей документации, как некий уникальный ID. Он должен быть единым во всех ваших изменениях/дополнениях. Все пометки ДОЛЖНЫ быть абсолютно одинаковыми! Это необходимо для удобства поиска.

Затем вам нужно создать основную папку, в которой вы будете локально работать, назови сразу её подобно ID твоего модуля. Например, `modular_meta/modules/shuttle_toggle`.

### Карты

В нашем репозитории не предполагается держать модульные карты (это которые с применением авто-мапперов).

Используются карты:
* оригинальные с офф ТГ (без изменений)
* заимствованные с других билдов (некоторые желательно не менять, уточните)
* наши самодельные = полностью независимые (например: ProtoBoxStation)

### Ресурсы: изображения (.png), звуки (.ogg), значки (.dmi) и прочие бинарники (= не Текст).

Git сам по себе может справиться с конфликтами двоичных файлов, однако Вы - нет. Для вас бинарник будет выглядеть как беспорядочный набор всякого, поэтому вносить изменения в основные Бинарные файлы категорически не рекомендуется.

Все (кроме TGUI, строк и конфигов со строками) добавленные нами файлы должны быть помещены в ту же модульную папку, что и ваш код. Это означает, что все локаально хранится в папке вашего модуля: звуки, значки и файлы кода. - УДОБНО!

- ***Пример:*** Решили Вы добавить нового моба для лаваленда.

  Прежде всего вы создаете свою модульную папку. Например: `modular_meta/modules/lavalandmob`

  Далее Вы создаете подпапки для каждого компонента (если нужно).
  Например: 
  * `/code` для кода
  * `/sounds` для звуковых файлов 
  * `/icons` для любых файлов картинок/значков.

  После этого вам нужно будет установить ссылки на ваши файлы в коде.

  ```byond
    /mob/lavaland/newmob
      icon = 'modular_meta/modules/lavalandmob/icons/mob.dmi'
      icon_state = "dead_1"
      sound = 'modular_meta/modules/lavalandmob/sounds/boom.ogg'
  ```

  Это гарантирует нам, что ваш код является полностью модульным и облегчит его будущие изменения.

- С прочими "нетекстовыми" файлами следует обращаться аналогичным образом, в зависимости от контекста каждого конкретного случая. Если у вас есть сомнения, обратитесь за советами и предложениями к сопровождающему проекта или другим участникам.

- Any additional clothing icon files you add MUST go into the existing files in master_files clothing section. (непонятно что имел ввиду автор)

### Папка `master_files` (oh yes Sir!)

Вы всегда должны помещать любые модульные переопределения значков, звуков, кода и т. д. в эту папку, и они **должны** соответствовать структуре папки основного кода.

Пример: `code/modules/mob/living/living.dm` -> `modular_meta/master_files/code/modules/mob/living/living.dm`

Это сделано для того, чтобы было проще выяснить, что вы или кто-то другой поменяли в Базовом файле, без необходимости поиска в определениях процедур.

Это также помогает предотвратить многократное переопределение одного и того же процесса модулями. Более подробная информация об этих типах редактирования расскажется позже.

### Полностью модульные части вашего кода

Раздел ниже относительно прост, там будет рассказано об основах Модульности с понятными примерами, так как руководство предназначено, скорее, для новичков.

Правило гласит, что если вы сможете обойтись без этого, то не следует вносить изменения в файлы основной код-базы. За некоторыми исключениями, которые будут упомянуты в ближайшее время.

Короче говоря, большая часть модульного кода будет размещена во вложенных папках вашей основной папки модуля **`modular_meta/modules/yourmodule/code/`**, с теми же правилами, что и в случае с остальными файлами. Не отражайте структуру папок основного кода в модульной папке!

Например, `modular_meta/modules/xenoarcheaology/code`, содержит весь код, инструменты, предметы и прочее, связанное с этим.

Такие модули, за исключением _очень_ простых, **должны** иметь в своей папке `readme.md`, содержащий следующее:

- ссылки на PR'ы, которые внедрили этот модуль или внесли в него какие-либо существенные изменения
- краткое описание модуля
- список файлов, измененных в основном коде, с кратким описанием изменений, а также список изменений в других модульных файлах, не являющихся частью того же модуля, которые были необходимы для правильной работы этого модуля
- (опционально) немного более подробная документация для корректировки кода на будущее, которая будет полезна при дальнейшем развитии и сопровождении
- авторство

***Примерный Шаблон:*** [Тык](module_template.md)

## Модульные переопределения (важно!!)

Обратите внимание, что можно модульно добавлять код перед или за основной процедурой, не редактируя исходную процедуру, а обращаясь к родительской процедуре с помощью `. = ..()` или `..()`. Аналогичным образом можно добавить новый var к существующему datum или obj, не редактируя напрямую файлы офф ТГ.

**Примечание о переопределении proc: Если вы можете, это не значит, что вы должны!!!**

В целом, такой подход является хорошей идеей и поощряется, когда это возможно. Однако это не жесткое правило, и иногда "//MASSMETA EDIT" предпочтительнее. Просто постарайтесь использовать здравый смысл в этом вопросе.

Например: пожалуйста, не вставляйте всю TG-процедуру в модульную переопределённую процедуру, внесите одно небольшое изменение, а затем объявите её "полностью модульной". Эти процедуры - абсолютный кошмар для поддержки, потому что как только что-то изменится, вам придется обновлять переопределенную процедуру.

Иногда вы даже не знаете о существовании переопределения, если оно компилируется нормально и не вызывает никаких ошибок. Это часто приводит к тому, что функции, которые были добавлены выше по течению, здесь отсутствуют. Так что да. Избегайте этого. Нет ничего страшного, если что-то не является полностью модульным. Иногда это лучший выбор из двух зол.

Лучшими кандидатами для модульных переопределений proc являются те, в которых вы можете просто добавить что-то после вызова родителя или ловко вплести вызов родителя в середину, чтобы достичь желаемого эффекта.

Производительность также следует учитывать, когда вы переопределяете горячую (часто вызываемую) процедуру (например, Life()), поскольку каждый дополнительный вызов увеличивает накладные расходы сервера. В таких случаях редактирование "//MASSMETA EDIT" намного критичны к общей производительности кода. Однако для большинства процедур об этом даже и не нужно беспокоиться.

### Эти модульные переопределения должны храниться именно в `master_files`, и вам следует по возможности избегать их размещения внутри модулей.

Для простоты предположим, что вы хотите заставить оружие искрить при выстреле для имитации дульной вспышки и вы хотите, чтобы это можно было использовать с любыми видами оружия.

В модульном файле можно начать с добавления переменной var.

```byond
/obj/item/gun
    var/muzzle_flash = TRUE
```

И все будет работать как полагается. После этого, допустим, вы захотите проверить var и вызвать искры после выстрела.
Зная, что исходный proc, вызываемый при стрельбе, является

```byond
/obj/item/gun/proc/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
```

вы можете определить для него дочернюю процедуру, которая будет вставлена в цепочку наследования связанных с ней процедур (выглядит на вид сложно, но в таких простых случаях, как этот, вам не нужно беспокоиться)

```byond
/obj/item/gun/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
    . = ..() //. is the default return value, we assign what the parent proc returns to it, as we call it before ours
    if(muzzle_flash)
        spawn_sparks(src) //For simplicity, I assume you've already made a proc for this
```

На этом мы закончили с основами.

### Немодульные изменения основного кода - ВАЖНО

Время от времени наступает момент, когда редактирование основных файлов становится неизбежным.

Пожалуйста, не забудьте записать факт их изменения в readme.md вашего модуля.

В этих случаях мы решили применить следующую стандартизацию с примерами:

- **Добавление:**

  ```byond
  //MASSMETA EDIT ADDITION BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
  var/adminEmergencyNoRecall = FALSE
  var/lastMode = SHUTTLE_IDLE
  var/lastCallTime = 6000
  //MASSMETA EDIT ADDITION END
  ```

- **Удаление:**

  ```byond
  //MASSMETA EDIT REMOVAL BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
  /*
  for(var/obj/docking_port/stationary/S in stationary)
    if(S.id = id)
      return S
  */
  //MASSMETA EDIT REMOVAL END
  WARNING("couldn't find dock with id: [id]")
  ```

  И для любых удалений, которые перемещаются в другие файлы:

  ```byond
  //MASSMETA EDIT REMOVAL BEGIN - SHUTTLE_TOGGLE - (Moved to modular_meta/shuttle_toggle/randomverbs.dm)
  /*
  /client/proc/admin_call_shuttle()
  set category = "Admin - Events"
  set name = "Call Shuttle"

  if(EMERGENCY_AT_LEAST_DOCKED)
    return

  if(!check_rights(R_ADMIN))
    return

  var/confirm = alert(src, "You sure?", "Confirm", "Yes", "No")
  if(confirm != "Yes")
    return

  SSshuttle.emergency.request()
  SSblackbox.record_feedback("tally", "admin_verb", 1, "Call Shuttle") //If you are copy-pasting this, ensure the 2nd parameter is unique to the new proc!
  log_admin("[key_name(usr)] admin-called the emergency shuttle.")
  message_admins(span_adminnotice("[key_name_admin(usr)] admin-called the emergency shuttle."))
  return
  */
  //MASSMETA EDIT REMOVAL END
  ```

- **Изменения:**

  ```byond
  //MASSMETA EDIT CHANGE BEGIN - SHUTTLE_TOGGLE - (Optional Reason/comment)
  //if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE) - MASSMETA EDIT - ORIGINAL
  if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE, SHUTTLE_DISABLED)
  //MASSMETA EDIT CHANGE END
      return 1
  ```
  
  при небольшом локальном изменении кода хорошим тоном будет в комментарии указать то что было там до вашего вмешательства.

## Особые случаи модульного кода

Из каждого правила есть исключения, обусловленные множеством обстоятельств.

### Определения
Свои модульные определения (defines) помещаем именно в папку **`massmeta/~meta_defines`**.

Если у вас есть определение, которое используется более чем в одном файле, оно **обязательно** должно быть объявлено там.

Если у вас есть define, который используется в одном файле и больше нигде не предполагается, объявите его вверху файла, а `#undef MY_DEFINE` - внизу файла. Это нужно для того, чтобы сохранить чистоту контекстных меню и не запутать тех, кто использует IDE (по типу VS Code) с автозаполнением.

(Сам byond работает с дефайнами только в директории **`code/__DEFINES`**, туда идет переопределение нашего файла.)

### Компоновка модульной папки
Чтобы сохранить общий стиль и обеспечить удобную навигацию по большинству модулей, а также контролировать количество файлов и папок в репозитории, вы должны следовать этой схеме.

Убедитесь, что имена папок точно соответствуют указанным.

Самая верхняя папка: module_id

**НЕ КОПИРУЙТЕ ФАЙЛОВУЮ СТРУКТУРУ ОСНОВНОГО КОДА ОФФОВ ТГ В СВОЙ МОДУЛЬ!!!**

**Code** (код): Все файлы .DM должны располагаться здесь.

- Делай так: /modular_meta/modules/module_id/code/disease_mob.dm
- НЕ так: /modular_meta/modules/module_id/code/modules/antagonists/disease/disease_mob.dm

**Icons** (изображения/иконки): Все файлы .DMI должны располагаться здесь.

- Делай так: /modular_meta/modules/module_id/icons/mining_righthand.dmi
- НЕ так: /modular_meta/modules/module_id/icons/mob/inhands/equipment/mining_righthand.dmi

**Sound** (звуки/музыка): Все файлы .OGG должны располагаться здесь.

- Делай так: /modular_meta/modules/module_id/sound/space_dragon_roar.ogg
- НЕ так: /modular_meta/modules/module_id/sound/creatures/space_dragon_roar.ogg

Файл Readme следует поместить в родительскую папку /modular_meta/modules/module_id.

**ДЕРЖИТЕ РАЗНЫЕ ТИПЫ ФАЙЛОВ ПО СВОИ ПАПКАМ!**

### Комментировнный код (= неиспользуемый) - НЕ ДЕЛАЙТЕ ЭТОГО

Если вы комментируете избыточный код в модулях - значит его нужно полностью удалить.

Даже если вы думаете, что кто-то собирается переделать то, что вы закомментировали, не делайте этого, gitblame существует не просто так, (прим. от переводчика: есть такая команда 'git blame', что позволяет показать, историю редактирования конкретной строки кода).

Это относится и к файлам, не комментируйте целые файлы, просто удалите это безобразие. Это поможет нам избежать их раздувания и бессмысленных комментариев. Тем более вы всегда можете посмотреть что было именно в этом файле просто нажав в гите "Посмотреть историю изменений".

**Это не относится к немодульным изменениям.**

### Иерархия инклюдов (includes.dm) ваших модулей

У Скайратов (в данном случае у Nova Sector) все новые файлы сразу включаются в общий файл tgstation.dme, что я считаю достаточно трудным для дальнейшней поддрежки, да и в целом не особо согласуется с их модульным принципом.

В корне папки /modular_meta лежит файл modular_meta.dm (он включен в общий tgstation.dme)

В этом файле описаны все дополнения, которые мы добавили в наш проект модульно. Они тоже представлены в виде .dm файлов. (например hardsuits.dm)

Каждый такой .dm файл в каждом модуле содержит в себе все наши дополнительные модульные-файлы (тоже .dm).

Таким образом мы соблюдаем некую красивую иерархию.

### Вставка в код своих строковых (.txt .json) и config файлов

Помещаете свои файлы в подпапку **`strings/~modular_meta_strings`**.
По аналогии и config-файлами **`config/~modular_meta_config`**.

Не забывайте выставлять правильный файловый путь к вашему файлу с учетом новой подпапки!

## Модульный TGUI (TG User Interface)

TGUI - еще один исключительный случай, поскольку он использует javascript и не может быть модульным, нежели же код DM.

ВСЕ файлы tgui находятся в папке `/tgui/packages/tgui/interfaces` и ее подкаталогах; отдельной папки для пользовательских интерфейсов Massmeta не существует.

### Изменение файлов самих офф ТГ

При изменении оригинальных файлов TGUI действуют те же правила, что и при изменении вышележащего кода DM, однако схема написания комментариев порой тут несколько иная.

Вы можете использовать как `// MASSMETA EDIT`, так и `/* MASSMETA EDIT */`, хотя в некоторых случаях вам придется использовать одно вместо другого. (в некотрых языках '//' - могут не являться комментированием, учтите это)

В целом, старайтесь, чтобы комментарии к изменениям находились на той же строке, что и само изменение. Предпочтительно внутри JSX-тега. Например:

```js
<Button
	onClick={() => act('spin', { high_quality: true })}
	icon="rat" // MASSMETA EDIT ADDITION
</Button>
```

```js
<Button
	onClick={() => act('spin', { high_quality: true })}
	// MASSMETA EDIT ADDITION START - another example, multiline changes
	icon="rat"
	tooltip="spin the rat."
	// MASSMETA EDIT ADDITION END
</Button>
```

```js
<SomeThing someProp="whatever" /* it also works in self-closing tags */ />
```

Если это не представляется возможным, вы можете заключить ваше редактирование в фигурные скобки, например так: 

```js
{/* MASSMETA EDIT ADDITION START */} 
<SomeThing>
	someProp="whatever"
</SomeThing>
{/* MASSMETA EDIT ADDITION END */}
```

### Создание новых файлов TGUI 

** ВАЖНО! При создании нового файла TGUI с нуля, пожалуйста, добавьте следующее в самом верху файла (строка 1):**

```js
// THIS IS A MASSMETA UI FILE
```

Таким образом, они легко идентифицируются как модульные файлы TGUI .tsx/.jsx. Собственно ничего больше делать и не нужно, комментарии "// MASSMETA EDIT" в модульном файле TGUI не нужны.

<!-- ## Exemplary PR's // TODO: REPLACE THESE!

Here are a couple PR's that are great examples of the guide being followed, reference them if you are stuck:

- <https://github.com/Skyrat-SS13/Skyrat-tg/pull/241>
- <https://github.com/Skyrat-SS13/Skyrat-tg/pull/111> -->

## В заключении

Терпение и труд - ТГ к*дера перетрут. Если мы будем последовательны, то в конечном итоге это избавит НАС от будущих болей в области ГМ, когда Нам (Вам) же придется разрешать конфликты вручную.
Благодаря более скрупулезному документированию будет сразу понятно, какие изменения были сделаны, где и с помощью каких функций, и все станет гораздо менее двусмысленным и запутанным.

Желаю удачи в ТГ к*динге. Помните, что сообщество всегда готово помочь вам, если вдруг понадобится помощь.
